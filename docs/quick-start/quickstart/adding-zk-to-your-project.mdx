---
sidebar_position: 4
---

import CodeWindow from '@site/src/components/CodeWindow';

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Adding Zernikalos engine to your project

## Configuration

<Tabs>
  <TabItem value="android" label="Android" default>
    After the basic setup, you'll need to publish the library locally:
    ```bash
    ./gradlew publishToMavenLocal
    ```

    Then add the dependency to your app's `build.gradle.kts` file:
    ```kotlin
    dependencies {
        implementation("dev.zernikalos:zernikalos:0.0.1")
    }
    ```

    If you haven't already, make sure you have `mavenLocal()` in your project's repositories:
    ```kotlin
    repositories {
        mavenLocal()
        // ... other repositories
    }
    ```
  </TabItem>
  <TabItem value="ios" label="iOS">
    We recommend using CocoaPods for integration:

    1. Add the following to your `Podfile`:
    ```ruby
    pod 'Zernikalos', :path => 'path/to/zernikalos/podspec'
    ```

    2. Run pod install:
    ```bash
    pod install
    ```
  </TabItem>
</Tabs>

## Import the engine

<Tabs>
  <TabItem value="android" label="Android" default>
    Before integrating Zernikalos, ensure you have:
    
    1. An Android project set up
    2.     2. OpenGL ES 3.0 or higher declared in your AndroidManifest.xml:
    ```xml
    <uses-feature android:glEsVersion="0x00030000" android:required="true" />
    ```
    3. A `GLSurfaceView` in your layout - This will be the canvas where Zernikalos renders your scene. 
       ([Android GLSurfaceView documentation](https://developer.android.com/reference/android/opengl/GLSurfaceView))

    Add a `GLSurfaceView` to your layout file:
    ```xml
    <android.opengl.GLSurfaceView
        android:id="@+id/render_surface"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    ```

    Initialize [Zernikalos class](../../api/-zernikalos/zernikalos/[android]-zernikalos/index) in your Activity's `onCreate` method:
    <CodeWindow
    language="kotlin"
    code={`val zernikalos = Zernikalos()
    val renderSurface = findViewById<GLSurfaceView>(R.id.render_surface)

    zernikalos.initialize(renderSurface, object : ZSceneStateHandler {
        // ZSceneStateHandler implementation will be covered in the next section
    })
    `}
    />

  </TabItem>
  <TabItem value="ios" label="iOS">
    // iOS documentation coming soon...
  </TabItem>
</Tabs>

## Implementing the ZSceneStateHandler

The `ZSceneStateHandler` interface is crucial for managing the lifecycle of your Zernikalos scene. Here's a basic implementation:

<CodeWindow
language="kotlin"
code={`zernikalos.initialize(renderSurface, object : ZSceneStateHandler {
    private var scene: ZScene? = null
    private var camera: ZCamera? = null

    override fun onReady(context: ZContext, done: () -> Unit) {
        scope.launch {
            // Create and set up your scene
            scene = ZScene()
            
            // Load your 3D assets
            val zko = loadResources()
            
            // Add objects to the scene
            scene?.addChild(zko.root)
            
            // Set the scene in the context
            context.scene = scene
            
            // Signal completion
            done()
        }
    }

    override fun onResize(context: ZContext, width: Int, height: Int, done: () -> Unit) {
        done()
    }

    override fun onRender(context: ZContext, done: () -> Unit) {
        // Your per-frame updates here
        done()
    }
})`}
/>

### Loading Resources

The most common first step is loading your 3D assets from a `.zko` file. Here's how to do it, just create a function like this:

<CodeWindow
language="kotlin"
code={`suspend fun loadResources(): ZKo = coroutineScope {
    val data = applicationContext.assets.open("your_model.zko")
    return@coroutineScope loadFromProto(data.readBytes())
}`}
/>

### Key Components

1. **Scene Setup**: In `onReady`, you create your scene and load resources
2. **Resource Loading**: Use `.zko` resource files containing your 3D models
3. **Scene Context**: The `ZContext` provides access to the current scene and rendering state
4. **Lifecycle Methods**:
   - `onReady`: Called when the engine is ready to start rendering
   - `onResize`: Called when the surface size changes
   - `onRender`: Called every frame for continuous updates

<!-- For a complete working example, check out our [sample project](../samples/basic-scene). -->

### Key Components

1. **Scene Setup**: In `onReady`, you create your scene and load resources
2. **Resource Loading**: Use `.zko` resource files containing your 3D models
3. **Scene Context**: The `ZContext` provides access to the current scene and rendering state
4. **Lifecycle Methods**:
   - `onReady`: Called when the engine is ready to start rendering
   - `onResize`: Called when the surface size changes
   - `onRender`: Called every frame for continuous updates

<!-- For a complete working example, check out our [sample project](../samples/basic-scene). -->