---
title: Adding Zernikalos to Your Project
description: How to integrate Zernikalos engine into your Android or iOS project
---

import { Tabs, Tab } from 'fumadocs-ui/components/tabs';

## Configuration

<Tabs items={['Android', 'iOS']}>
  <Tab value="Android">
    After the basic setup, you'll need to publish the library locally:

    ```bash
    ./gradlew publishToMavenLocal
    ```

    Then add the dependency to your app's `build.gradle.kts` file:

    ```kotlin
    dependencies {
        implementation("dev.zernikalos:zernikalos:0.0.1")
    }
    ```

    If you haven't already, make sure you have `mavenLocal()` in your project's repositories:

    ```kotlin
    repositories {
        mavenLocal()
        // ... other repositories
    }
    ```
  </Tab>
  <Tab value="iOS">
    We recommend using CocoaPods for integration:

    1. Add the following to your `Podfile`:

    ```ruby
    pod 'Zernikalos', :path => 'path/to/zernikalos/podspec'
    ```

    2. Run pod install:

    ```bash
    pod install
    ```
  </Tab>
</Tabs>

## Import the engine

<Tabs items={['Android', 'iOS']}>
  <Tab value="Android">
    Before integrating Zernikalos, ensure you have:

    1. An Android project set up
    2. OpenGL ES 3.0 or higher declared in your AndroidManifest.xml:

    ```xml
    <uses-feature android:glEsVersion="0x00030000" android:required="true" />
    ```

    3. A `GLSurfaceView` in your layout - This will be the canvas where Zernikalos renders your scene. ([Android GLSurfaceView documentation](https://developer.android.com/reference/android/opengl/GLSurfaceView))

    Add a `GLSurfaceView` to your layout file:

    ```xml
    <android.opengl.GLSurfaceView
        android:id="@+id/render_surface"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
    ```

    Initialize Zernikalos in your Activity's `onCreate` method:

    ```kotlin
    val zernikalos = Zernikalos()
    val renderSurface = findViewById<GLSurfaceView>(R.id.render_surface)

    zernikalos.initialize(renderSurface, object : ZSceneStateHandler {
        // ZSceneStateHandler implementation will be covered in the next section
    })
    ```
  </Tab>
  <Tab value="iOS">
    iOS documentation coming soon...
  </Tab>
</Tabs>

## Implementing the ZSceneStateHandler

The `ZSceneStateHandler` interface is crucial for managing the lifecycle of your Zernikalos scene. Here's a basic implementation:

```kotlin
zernikalos.initialize(renderSurface, object : ZSceneStateHandler {
    private var scene: ZScene? = null
    private var camera: ZCamera? = null

    override fun onReady(context: ZContext, done: () -> Unit) {
        scope.launch {
            // Create and set up your scene
            scene = ZScene()

            // Load your 3D assets
            val zko = loadResources()

            // Add objects to the scene
            scene?.addChild(zko.root)

            // Set the scene in the context
            context.scene = scene

            // Signal completion
            done()
        }
    }

    override fun onResize(context: ZContext, width: Int, height: Int, done: () -> Unit) {
        done()
    }

    override fun onRender(context: ZContext, done: () -> Unit) {
        // Your per-frame updates here
        done()
    }
})
```

### Loading Resources

The most common first step is loading your 3D assets from a `.zko` file. Here's how to do it:

```kotlin
suspend fun loadResources(): ZKo = coroutineScope {
    val data = applicationContext.assets.open("your_model.zko")
    return@coroutineScope loadFromProto(data.readBytes())
}
```

### Key Components

1. **Scene Setup**: In `onReady`, you create your scene and load resources
2. **Resource Loading**: Use `.zko` resource files containing your 3D models
3. **Scene Context**: The `ZContext` provides access to the current scene and rendering state
4. **Lifecycle Methods**:
   - `onReady`: Called when the engine is ready to start rendering
   - `onResize`: Called when the surface size changes
   - `onRender`: Called every frame for continuous updates
